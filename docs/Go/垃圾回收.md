###	三色标记（黑白灰）

1. 把所有的对象都放到白色的集合中
2. 从根节点（from globals and goroutine stacks）开始遍历对象，把遍历到的白色对象从白色集合中放到灰色集合中
3. 遍历灰色集合中的对象，把灰色对象引用的白色集合的对象放入到灰色集合中，同时把遍历过的灰色集合中的对象放到黑色的集合中
4. 循环步骤3，直到灰色集合中没有对象
5. GC过程中，所有新分配对象都立刻标记为黑色
6. 白色集合中的对象就是不可达对象，对其进行回收

### 屏障技术

##### 强三色不变式

> 强制性的不允许黑色对象引用白色对象

##### 弱三色不变式

> 黑色对象可以引用白色对象，但是这个白色对象仍然存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象。

##### 插入屏障

> 插入屏障拦截将白色指针插入黑色对象的操作，标记其对应对象为灰色状态

##### 删除屏障

> 删除灰色对象(A)指向的白色对象(B)的指针时，将白色对象(B)置为灰色对象

##### 混合写屏障

> 结合插入屏障和删除屏障优点

### STW(stop the world)

- 1.3以前的版本使用标记-清扫的方式，整个过程都需要STW。
- 1.3版本分离了标记和清扫的操作，标记过程STW，清扫过程并发执行。
- 1.5版本在标记过程中使用三色标记法。回收过程主要有四个阶段，其中，标记和清扫都并发执行的，但标记阶段的前后需要STW一定时间来做GC的准备工作和栈的re-scan。
- 1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。

### GC触发

- gcTriggerAlways: 强制触发GC
- gcTriggerHeap: 当前分配的内存达到一定阈值时触发，这个阈值在每次GC过后都会根据堆内存的增长情况和CPU占用率来调整
- gcTriggerTime: 当一定时间没有执行过GC就触发GC（2分钟）
- gcTriggerCycle: runtime.GC()调用

### 逃逸分析

`go build -gcflags="-m" . 2>&1`