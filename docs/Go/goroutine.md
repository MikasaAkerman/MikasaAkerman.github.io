### 线程

共享堆，不共享栈，线程的切换一般也由操作系统调度

### 协程

共享堆，不共享栈，协程切换由自己控制。避免上下文切换的额外耗费，兼顾了多线程的优点，简化了高并发程序的复杂。

### MGP模型

`M`指的是`Machine`，一个`M`直接关联了一个内核线程，由操作系统管理。
`P`指的是”processor”，代表了`M`所需的上下文环境，也是处理用户级代码逻辑的处理器。它负责衔接M和G的调度上下文，将等待执行的G与M对接。
`G`指的是`Goroutine`，其实本质上也是一种轻量级的线程。包括了调用栈，重要的调度信息，例如channel等。

> M:N
>
> > 多个G在多个内核线程上跑
>
> 偷任务
>
> > 一个P所分配的G执行完以后，先尝试从global runqueue中获取G，如果global runqueue中也没有G了，尝试从其它P中偷取G，每次从其它P的runqueque中偷取一半

### 优点

1. 开销小(*goroutine：*2KB ，线程：8MB)
2. 调度性能好，避免上下文(程序状态)切换的同时兼顾多线程优点，简化并发程序复杂度。

### 缺点

1. 无法保证调度的公平性，当一个goroutine一直占用cpu而不进入阻塞时，P不会主动调度该协程

### 协程数量

1. CPU密集型：thread数量+1，避免上下文切换开销
2. IO密集型：thread*2，某些线程在等待io操作时，其它线程可以继续使用cpu